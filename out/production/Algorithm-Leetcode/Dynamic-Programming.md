# Dynamic Programming
## Introduction
动态规划算法是用于求解决策过程最优化问题的数学方法.


与分治算法相似，也是通过组合子问题的解来求解原问题. 
但是动态规划算法对每个子问题只求解一次，避免了不必要的重复工作.
如果随后再次出现需要此子问题的解，只需查找保存的结果，而不必重新计算. 


实际上动态规划最核心的思想就是: **付出额外的内存空间以节省计算时间，
而节省的时间可能是非常巨大的.**

## 与分治算法的异同
首先，二者都是分治思想的体现: 即将复杂的原问题分而治之. 
先将原问题不断分解成若干较小规模的子问题(小到可以直接求解)，
然后进行递归地求解，再通过合并子问题的解，产生最终原问题的解.


但对于要使用分治思想的问题中有一类问题，非常不适合使用分治算法直接求解. 
即最优化问题(这类问题拥有多个可能的解，而我们希望从中找到一个最满意的解). 
因为最优化问题具有重叠子问题(overlapping sub-problems)的性质,
所以如果具有重叠子问题性质的问题使用分治算法，
在递归求解过程中对于不同的子问题，就会大量重复计算相同的子子问题，
产生非常高的代价.


而动态规划算法正是专门解决此类问题的. 
它在求解过程中，对每一个不同的子问题只求解一次. 
若之后出现相同的子问题，只需查找保存的结果, 避免了不必要的重复工作.


**总之，分治算法用于解决子问题不相交的情况，
  动态规划算法用于解决子问题重叠的情况.**


从具体实现的角度来看，分治算法通常只能利用递归求解问题. 
而动态规划方法使用的是一种带备忘功能的递归过程来求解问题. 
除此以外，动态规划还有一种非常高效的非递归实现方法——自底向上.

## 动态规划问题的两大性质
一个可使用动态规划算法求解的最优化问题，应该具备下面两个关键要素: 
**最优子结构(optimal substructure)
  和子问题重叠(overlapping sub-problems)**.
  
  
### 最优子结构
一个问题满足最优子结构的性质，
当且仅当该问题的最优解由相关子问题的最优解组合而成，
而且这些子问题可以独立求解.


最优子结构并不是动态规划的特有性质，贪心算法也具有最优子结构.

#### 寻找最优子结构的通用模式
1. 得到这个问题的一个解需要至少做出一个选择. 而做出这样的选择会产生一个或多个待解决的子问题.
2. 对于一个给定的问题，假定已经知道做出哪一步选择会产生最优解.
3. 做出这步选择后，确定会产生哪些子问题，以及如何最好地刻画产生的子问题空间.
4. 利用"剪切-粘贴"(cut-and-paste)的方法证明: 
这些构成原问题最优解的子问题的解，就是这些子问题的最优解.

“剪切-粘贴"方法(实际上就是一种反证法): 假定每个子问题的解不是子问题的最优解，
然后通过从原问题中“剪切”掉这些"非最优解”，
然后“粘贴”新的“最优解”后，得到了原问题一个更优的解. 
这就与“用于求解原问题最优解的子问题，它们自身的解就是它们自身的最优解. ”的前提产生矛盾.


以上这个通用模式可能让人难以理解，后文还会通过实例分析比较形象地展现这一过程.


对于不同问题的领域，最优子结构的不同体现在两个方面:
1. 原问题的最优解涉及多少个子问题
2. 确定最优解使用哪些子问题时，要考虑多少种选择.

### 重叠子问题
适合使用动态规划求解的最优化问题还应该具备第二个性质是子问题空间必须足够“小” 
(问题的递归算法会反复求解相同的子问题，而不是一直产生新的问题). 
如果递归算法反复地求解相同的子问题，
我们就称最优化子问题具有重叠子问题的性质
(与之相对的是，如果递归算法一直产生全新的子问题，那么就适合使用分治方法来求解).


动态规划通常这样利用重叠子问题的性质: 
对于每个子问题只求解一次，然后将解存入一个表中. 
当再次需要这个子问题时，直接查表得解(每次查表的代价为常量时间).


## 动态规划的两种实现方法
### Top-down with memoization
Memoization ensures that a method doesn't run for the same inputs more than once by 
keeping a record of the results for the given inputs (usually in a hash map).

我们可以保持自然递归的自顶向下的策略求解动态规划问题(和分治方法一致)，
但为了避免反复求解重复的子问题，
我们在自然低效的递归算法中加入备忘机制. 
通过维护一个记录子问题解的表项，随后每次遇到同一子问题时，
只需简单查表返回其解即可.


此方法仍按照最自然的递归形式编写过程，但过程中会保存每一个子问题的解(保存在数组或散列表中). 
递归过程会首先检查是否已经保存过这个子问题的解，
如果保存过，直接返回这个解，否则计算出这个解后保存. 
我们就称这样的递归过程为带备忘的(memoized).

### Bottom-up method
Going bottom-up is a way to avoid recursion, 
saving the memory cost that recursion incurs 
when it builds up the call stack.

Put simply, a bottom-up algorithm "starts from the beginning," 
while a recursive algorithm often 
"starts from the end and works backwards."


This makes top-down algorithm vulnerable to a stack overflow error, 
where the call stack gets too big and runs out of space.

这种方法不使用递归编写. 而是先将子问题按照规模排序，
由小到大地进行求解并逐一保存. 
因此和带备忘的自顶向下法一样，
自底向上地求解方法也能保证每个子问题只会求解一次. 
当求解某个子问题时，它所依赖的子子问题必然已经求解完毕.